---
date: 2017-02-22 09:20
status: public
title: 数据类型转换
---

#（隐式）自动类型转换
## 小类型到大类型的转换:
![数据类型隐式转换](http://wx2.sinaimg.cn/mw690/a6e9cb00ly1fd512ckyagj21kw0yf4be.jpg)
)
>图中 6 个实心箭头表示无信息丢失的转换，3 个虚线箭头表示可能有精度损失的转换。

*隐式转换示例：*
``` java
byte b = 5; //这里没有类型转换，只是普通的赋值
long l = 6; //int -> long
byte m = 5; //0000 0101
short n = -2;//1111 1111 1111 1110
//m -> int:0000 0000 0000 0000 0000 0000 0000 0101
//n -> int:1111 1111 1111 1111 1111 1111 1111 1110
int j = m + n;
//j: 00000000 00000000 00000000 0000 0011
int i = 123456789;
float f = i;//f = 1.23456792E8
```
>两个操作数进行运算，会自动将两个操作数转换为同一种类型，然后再进行计算。
如果两个操作数中有一个是 double 类型，另一个操作数将会转换为 double 类型。
否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。
否则，如果其中一个操作数是 long 类型，另一个操作数将会转换为 long 类型。
否则，两个操作数都将被转换为 int 类型。

--------------------------------------
#（显式）强制类型转换
##大类型到小类型的转换：
double -> float -> long -> int -> short -> byte
double -> float -> long -> int -> char

*显式转换示例：*
```java
byte m = 5;
byte n = 6;
//语法： （转换的类型）被转换的值。
byte k = (byte)(m + n);//11

int i = 128;
byte j = (byte)i;//-128
//i: 0111 1111 + 1 = 1000 0000
//i: 0000 0000 0000 0000 0000 0000 1000 0000
//j: 1000 0000
//这里将i转换为byte后从128转换为了-128
```
>由此可见，显式转换有可能将数值改变，所以在进行显式转换时一定要确定该转换是否会对数值造成影响，慎用

### 浮点型强制转换为整型的时候会直接舍弃小数部分，若想进行四舍五入则需要使用 Math.round方法：
```java

double x = 9.997;
int y = (int)x;//y = 9
int z = (int)Math.round(x);//z = 10
```
#### 如果试图讲一个数值从一种类型强制转换为另一种类型，而又超出了目标类型的表示范围，结果就会截断成一个完全不同的值，如：(byte)300 的实际值为 44.
------------------
### 运算符优先级: