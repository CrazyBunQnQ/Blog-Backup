---
date: 2017-03-07 09:34
status: public
title: 面向对象（三）
---

## 继承 extends ##
关键字 extends 表明正在构造的新类派生于一个已存在的类。已存在的类称为**基类（base class）或父类（parent class）**；心累称为**子类（subclass 或 child class）或派生类（derived class）**。

继承提高代码的复用性，避免代码重复。

语法：

```java
    class 子类 extends 父类 {
        ...
    }
```

- Java规定一个子类只能继承一个父类，Java是单一继承的
- 子类拥有父类的所有属性及方法，同时也可以定义自己的成员变量和方法
- 父类中定义所有子类共有的属性及方法，子类中定义自己特有的属性及方法，子类继承父类后，拥有父类所有的属性及方法，同时也拥有自己特有的属性及方法
- 继承并不仅限于一个层次

supper
当前对象的父类


### 多态 ###

有一个判断是否应该设计为继承关系的简单规则，就是“is-a”（就是它）规则，它表明**子类的每个对象也是父类的对象。**例如，每个经理都是员工，因此可以将经理设计为员工的子类，反过来却不行，并不是每个员工都是经理。

“is-a”规则的另一种表述法是**置换法则**。它表明**程序中出现父类对象的任何地方都可以用子类对象置换（引用类型的隐式转换）**。例如，可以将一个子类的对象赋值给父类变量：

```java
    父类 a = new 子类();//创建子类型对象，但赋值为父类型变量a
    FlyObject fo;
    fo = new FlyObject(...);//正常的创建对象
    fo = new Bee(...);//创建子类型对象，但赋值为父类型变量a
```

*Java 中，对象变量是**多态的。**一个 FlyObject 变量可以引用一个 FlyObject 类对象，也可以引用一个 FlyObject 类的任何一个子类的对象。通过父类型的引用只能访问父类定义的成员变量和方法，不能访问子类扩展部分。*

### 引用类型转换 ###
回顾一下基本类型转换：
小→大：隐式转换
大→小：强制转换（丢失精度）

#### 引用类型转换也类似： ####
小→大：隐式转换

```java
    FlyObject fo = new Bee();
```

大→小：强制转换（可能会出现运行异常 ClassCastException）

```java
    Bee b = (Bee)fo;
```

Java 建议每次强制转换时通过 instanceof 进行判断
语法

```java
    引用变量 instanceof 类型//返回 boolean 值
    if (fo instanceof Bee){
        Bee b = (Bee)f;
    } else {
        System.out.println("不能强制转换");
    }
```

instanceof 判断会在**引用指向该对象就是该类型/或实现该接口**时返回 true 。

#### 综上所述： ####
- 只能在继承层次内进行类型转换
- 在将父类转换成子类之前，应该使用 instanceof 进行检查。

>并不推荐用类型转调整对象的类型，应该尽量少用类型转换和 instanceof 运算符。

### package：
Java 允许使用**包（package）**将类组织起来。借助包可以方便的组织自己的代码，并将自己的代码与别人提供的代码库分开管理。
标准的 Java 类库分布在多个包中，包括 java.lang、java.util 和 java.net 等。标准的 Java 包具有一个层次结构。如果痛硬盘的目录嵌套一样，也可以使用嵌套层次组织包。

**使用包的主要原因是确保类名的唯一性。避免冲突。**
为了保证包名的绝对唯一性，建议将公司的因特网域名（域名肯定是独一无二的）以逆序的形式作为包名，并且对于不同的项目使用不同的子包（所有字母小写）。例如，谷歌域名 google.com 的逆序形式为 com.google。这个包还可以被进一步划分成子包，如 com.google.android。
>从编译器的角度来看，嵌套的包之间没有任何关系。

#### import： ####
一个类可以使用所书包中的所有类，以及其他包中的**共有类（public class）**
我们可以用两种方式访问另一个包中的共有类：
**1.在每个类名之前添加完整的包名**：

```java
    java.util.Date today = new java.util.Date();
```

如果代码中多处地方用到 Date，显然很累，这时可以用第二种方式

**2. 使用 import 语句导入一个特定的类或者整个包**:

```java
    import java.util.*;
```

之后就可以使用

```java
    Date today = new Date();
```

而无需再前面加上包前缀了。还可以导入一个包中的特定类：

```java
    import java.util.Date;
```

>**只能用星号（*）导入一个包，而不能使用` import java.* `或` import.java.*.* `导入以 java 为前缀的所有包。**

作用：不同包下中的类，不能直接访问，需要通过 import 来导入后才能访问，同一个包中的类可以直接访问

## 重写（覆盖） ##
当父类中定义的方法满足不了当前的需求时，需要重写方法。

**子类可以重写来自父类的方法，即：方法名一样，参数列表也一样，方法的实现不一致**。重写看对象。

>（当然你想让方法的实现一样那我也没办法~）

#### 重写遵循规则： ####
>**两同：**
- 方法名相同
- 参数列表相同

>**两小：**
- **子类的返回值范围小于等于父类**
>若父类返回值为void，子类的返回值也为 void
>若父类返回值为基本类型，子类的返回值也为基本类型
>若父类的返回值为引用类型，子类的返回值类型小于等于父类的返回类型。
- 子类抛出的异常类型小于等于父类。
>
>

>**一大：**
- 子类重写后的方法修饰符要大于等于父类。

#### 重载和重写的区别 ####
- 重写：
1.发生在父子类中的两个类，方法名相同，参数列表相同，方法实现不同。
2.重写遵循“运行期绑定”，根据对象类型来调用。

- 重载：
1.发生在一个类中，方法名相同，参数列表不同。
2.重载遵循“编译期绑定”，根据参数列表来调用。
