---
title: 数据类型与类型转换
date: 2017-02-20 09:31
categories: Java 基础
tags: 
- 数据类型
- 类型转换
---

Java是一种强类型语言。这就意味着必须为每一个变量声明一种类型。在Java中一共有四种共8个基本数据类型。

<!-- more -->

## 基本数据类型
|种类|包含的基本数据类型|
|:---|:---|
|整型|byte、short、int、long|
|浮点型|float、double|
|字符型|char|
|布尔型|boolean|

---
</br>
### Java整型:

**整型用于表示没有小数部分的值，允许位负数。**

|类型|外号|存储需求|取值范围|
|:---|:---|:-------|:-------|
|byte|字节|1字节|-128~127|
|short|短整型|2字节|-32 768~32 767|
|int|整型|4字节|-2 147 483 648~2 147 483 647(刚好超过20亿)|
|long|长整型|8字节|-9 223 372 036 854 775 808~9 223 372 036 854 775 807|

**int 位整型的默认运算类型，长整型数值后需要有个L或l后缀**

>1T = 1024G
1G = 1024M
1M = 1024KB
1KB = 1024B
1B = 8bit

示例

    byte c = 128; //超范围复赋值会报错
    //等同于 byte d = 5;
    byte d = 3 + 2; //int --->byte
    byte m = 3;
    byte n = 2;
    byte k = m + n;//int ---> byte 这里会报错
    int a = 2147483647;
    int b = 1;
    int c = m + n;//此时c = -2147483648 最大加一变最小

>java 是一种先编译后运行的语言。
>在编译期间，java 是不能直接知道变量的具体值的。
>所以在这里，编译的时候不知道m和n的具体数值，也就不能确定 m + n 的结果是否会超出 byte 的范围。
>在 Java 中，整型的默认运算类型是 int。所以比 int 小的数据类型，在参与运算的时候回自动转换为 int 类型。

**总结：**
**1.在 Java 中，整型的字面量默认是 int 类型。**
**2.在 Java 中，整形的默认运算类型是 int 类型。**
**3.有比 int 小的类型，在运算的时候会自动转成 int 类型。**
**4.有比 int 大的类型，在运算的时候会转成最大的类型来运算。**

---
</br>
### Java浮点型

**浮点型用于表示有小数部分的数值：**

|类型|外号|存储需求|取值范围|
|:---|:---|:-------|:-------|
|float|单精度浮点型|4字节|±3.402 823 47E + 38F（有效位数6~7位）|
|double|双精度浮点型|8字节|±1.797 693 134 862 315 70E + 308（有效位数15位）|

**float 类型的数值有一个后缀F或f，没有后缀的浮点数值默认为 double 类型。也可以在浮点数后面添加后缀 D 表示 double 类型的数值。**

float 类型含 1 位符号位，8 位指数位和 23 位尾数位
double 类型含 1 位符号位，11位指数位和 52 位尾数位

>总结：
**1. 在 Java 中，小数的字面量默认是 double 类型。**
**2. float 比 int 的范围大，int 比 float 的精度达。**
**3. double 比 long 的范围大，long 比 double 的精度大。**

**三个特殊的浮点数值：**

|数值|表示方式|
|:---|:---|
|正无穷大|Double.POSITIVE_INFINITY|
|负无穷大|Double.NEGATIVE_INFINITY|
|NaN(不是一个数字)|Double.NaN|

**需要注意的是， 不能像如下代码一样检测一个值是否等于 NaN ：**

    if (x == Double.NaN) //这个判断结果永远是 false

**因为所有的“非数值”的值都认为是不相同的，但是可以使用 Double.isNaN 方法来检测一个值是否“不是一个数”：**

    if (Double.isNaN(x)) //检测x是否“不是一个数值”，若 x 不是一个数值则返回 true，否则返回 false

---
</br>
### 字符型：char 类型，用来表示单个字符。

**char 类型通常用来表示字符常量，例如'A'是编码为 65 所对应的字符常量，它与"A"不同，"A"是一个包含字符'A'的字符串。**

- **Unicode编码：** 是全球范围内的编码方法，可以表示十六进制值，其范围从 \u0000 到 \Uffff ，包含了英文、中文、日文、韩文等共 8 万多个字符。
- **char：** 用 UTF-16 编码描述一个代码单元，含 2 个字节，无符号的整数。范围是0~65535，可以表示 Unicode 最常用的部分.
>`但是，强烈建议不要在程序中使用 UTF-16 编码，尽量使用 UTF-8 编码，除非确实需要对 UTF-16 代码单元进行操作。`

**特殊字符的转义序列符**

|转义序列|名称|Unicode值|转义序列|名称|Unicode值|
|:-------|:---|:--------|:------|:---|:--------|
|\b|退格|\u0008|\"|双引号|\u0022|
|\t|制表|\u0009|\'|单引号|\u0027|
|\n|换行|\u000a|\\|反斜杠|\u005c|
|\r|回车|\u000d||||

**代码示例**

    char c = 65;
	System.out.println(c) //'A'
	char b = 'b';
	System.out.println((int)b);66
	char d = '中';
	System.out.println((int)d);//20013

>常用字符
'0' 48，将'1'转化为int类型1只需要将'1'减去'0'或48;
'A' 65
'a' 97
\为转义字符	

---
</br>
### Java boolean 类型（布尔型）

**boolean（布尔）类型有两个值：false（假）和 true（真），用来判定逻辑条件。`整数型和布尔值之间不能进行相互转换`。**

</br>
## 数据类型转换
### （隐式）自动类型转换

**小类型到大类型的转换:**
![数据类型隐式转换](http://wx2.sinaimg.cn/mw690/a6e9cb00ly1fd512ckyagj21kw0yf4be.jpg)

>图中 6 个实心箭头表示无信息丢失的转换，3 个虚线箭头表示可能有精度损失的转换。

隐式转换示例：

	byte b = 5; //这里没有类型转换，只是普通的赋值
	long l = 6; //int -> long
	byte m = 5; //0000 0101
	short n = -2;//1111 1111 1111 1110
	//m -> int:0000 0000 0000 0000 0000 0000 0000 0101
	//n -> int:1111 1111 1111 1111 1111 1111 1111 1110
	int j = m + n;
	//j: 00000000 00000000 00000000 0000 0011
	int i = 123456789;
	float f = i;//f = 1.23456792E8

>两个操作数进行运算，会自动将两个操作数转换为同一种类型，然后再进行计算。
如果两个操作数中有一个是 double 类型，另一个操作数将会转换为 double 类型。
否则，如果其中一个操作数是 float 类型，另一个操作数将会转换为 float 类型。
否则，如果其中一个操作数是 long 类型，另一个操作数将会转换为 long 类型。
否则，两个操作数都将被转换为 int 类型。

---
</br>
###（显式）强制类型转换
**大类型到小类型的转换：**

double -> float -> long -> int -> short -> byte
double -> float -> long -> int -> char

显式转换示例：

	byte m = 5;
	byte n = 6;
	//语法： （转换的类型）被转换的值。
	byte k = (byte)(m + n);//11

	int i = 128;
	byte j = (byte)i;//-128
	//i: 0111 1111 + 1 = 1000 0000
	//i: 0000 0000 0000 0000 0000 0000 1000 0000
	//j: 1000 0000
	//这里将i转换为byte后从128转换为了-128

>由此可见，显式转换有可能将数值改变，所以在进行显式转换时一定要确定该转换是否会对数值造成影响，慎用

**浮点型强制转换为整型的时候会直接舍弃小数部分，若想进行四舍五入则需要使用 Math.round方法：**

	double x = 9.997;
	int y = (int)x;//y = 9
	int z = (int)Math.round(x);//z = 10

>如果试图将一个数值从一种类型强制转换为另一种类型，而又超出了目标类型的表示范围，结果就会截断成一个完全不同的值，如：(byte)300 的实际值为 44.

## 引用类型
待补充